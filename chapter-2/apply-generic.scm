(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (drop (apply proc (map contents args)))
          (if (= (length type-tags) 2)
              (let ((a1 (car args))
                    (a2 (cadr args)))
                (let ((level1 (level a1))
                      (level2 (level a2)))
                  (cond ((> level1 level2) (apply-generic op a1 (raise a2)))
                        ((< level1 level2) (apply-generic op (raise a1) a2))
                        (else (error "no such method --APPLY-GENERIC" (list op type-tags))))))
              (error "no such method --APPLY-GENERIC" (list op type-tags)))))))

(define (level x)
  (let ((type (type-tag x))
        (data (contents x)))
    (cond ((eq? type 'rational) 2)
          ((eq? type 'scheme-number) (if (exact-integer? data) 1 3))
          ((eq? type 'complex) 4)
          (else (error "no such types --LEVEL" type)))))

(define (drop? x)
  (if (not (boolean? x)) ;; 防止对equ?过程生成的结果进行drop 或 project
      (let ((dropped (project x)))
        (if (and (> (level x) 1)
                 (equ? (raise dropped) x))
            true
            false))
      false))
